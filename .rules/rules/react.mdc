---
description: React best practices and patterns for modern web applications
globs: **/*.tsx, **/*.jsx, components/**/*
---
## React ベストプラクティス

Reactアプリケーションを効果的に開発するためのベストプラクティスを以下にまとめました。プログラミング用語は適度に英語のまま残しています。

### コンポーネント構造 (Component Structure)
* **クラスコンポーネントよりも関数コンポーネントを使用する**: React Hooksの登場により、関数コンポーネントは状態とライフサイクル機能にアクセスできるようになり、より簡潔でテストしやすいコードを書くことができます。
* **コンポーネントは小さく、焦点を絞る**: 各コンポーネントには単一の責任を持たせ、特定のタスクやUIの一部に特化させます。
* **再利用可能なロジックはカスタムフックに抽出する**: コンポーネント間で共有したい状態管理や副作用などのロジックは、カスタムフックとして分離し、再利用性を高めます。
* **継承よりもコンポジションを使用する**: コンポーネントの再利用には、継承ではなく、子コンポーネントをプロップとして渡すなどのコンポジション（合成）を活用します。
* **TypeScriptで適切なpropsの型を実装する**: コンポーネントのprops（プロパティ）の型をTypeScriptで明示的に定義することで、型安全性を確保し、バグを減らします。
* **大規模なコンポーネントは小さく、焦点を絞ったものに分割する**: 複雑なコンポーネントは、管理しやすく、テストしやすい小さなコンポーネントに分割します。

### Hooks (Hooks)
* **Hooksのルールに従う**: `useState` や `useEffect` などのHooksは、コンポーネントのトップレベルで呼び出す、ループや条件分岐の中では呼び出さないなど、Reactの定めるルールに従います。
* **再利用可能なロジックにはカスタムフックを使用する**: コンポーネント間で共通するロジックや状態管理はカスタムフックとして抽象化し、コードの重複を防ぎます。
* **Hooksは焦点を絞り、シンプルに保つ**: 各フックは単一の目的を持ち、複雑になりすぎないようにします。
* **`useEffect` の依存配列を適切に使用する**: `useEffect` の依存配列は、エフェクトが再実行されるタイミングを制御するために重要です。不必要な再実行を避け、依存関係を正確に指定します。
* **必要に応じて `useEffect` でクリーンアップを実装する**: `useEffect` からクリーンアップ関数を返すことで、イベントリスナーの解除やタイマーのクリアなど、副作用の後処理を適切に行います。
* **Hooksをネストしない**: Hooksを条件分岐やループ、あるいは別の関数の内部でネストすることは避けるべきです。常にトップレベルで呼び出します。

### 状態管理 (State Management)
* **ローカルコンポーネントの状態には `useState` を使用する**: コンポーネント内部での単純な状態管理には `useState` を使用します。
* **複雑な状態ロジックには `useReducer` を実装する**: 複数の状態が複雑に絡み合う場合や、状態遷移が明確な場合は `useReducer` を使用して、Reduxのようなパターンで状態を管理します。
* **共有状態にはContext APIを使用する**: グローバルな状態や、多くのコンポーネントで共有される状態には、ReactのContext APIを使用してProp Drilling（プロップのバケツリレー）を避けます。
* **状態は使用される場所にできるだけ近くに保つ**: 状態を定義するスコープは、その状態を必要とするコンポーネントに最も近い場所にするべきです。これにより、再レンダリングの範囲を最小限に抑えます。
* **適切な状態管理によってProp Drillingを避ける**: Propsを何階層も深く渡すProp Drillingは避け、Context APIや状態管理ライブラリを活用して、必要なコンポーネントに直接状態を渡します。
* **状態管理ライブラリは必要な場合にのみ使用する**: ReduxやZustandなどの外部状態管理ライブラリは、アプリケーションの規模や複雑性が本当に必要とする場合にのみ導入を検討します。

### パフォーマンス (Performance)
* **適切なメモ化 (`useMemo`, `useCallback`) を実装する**: 計算コストの高い値や、再レンダリングによって不要に再作成される関数をメモ化するために `useMemo` や `useCallback` を使用します。
* **高コストなコンポーネントには `React.memo` を使用する**: Propsが変更されない限り再レンダリングしたくないコンポーネントは `React.memo` でラップします。
* **不必要な再レンダリングを避ける**: コンポーネントの再レンダリングの原因を理解し、状態の更新を最適化して不必要なレンダリングを減らします。
* **適切なLazy Loadingを実装する**: コード分割を行い、必要に応じてコンポーネントを遅延ロードすることで、初期ロード時間を短縮します。
* **リストには適切な `key` propsを使用する**: リスト内の要素には一意で安定した `key` propを設定することで、Reactがリストのアイテムを効率的に識別し、再レンダリングの最適化を行います。
* **レンダリングパフォーマンスのプロファイリングと最適化を行う**: React Developer Toolsのプロファイラー機能などを使用して、パフォーマンスのボトルネックを特定し、最適化を行います。

### フォーム (Forms)
* **フォーム入力にはControlled Componentsを使用する**: フォーム入力の状態をReactのstateで管理し、入力の値を単一の信頼できる情報源として扱います。
* **適切なフォームバリデーションを実装する**: ユーザーからの入力を検証し、エラーメッセージを適切に表示することで、データの整合性を保ちます。
* **フォームの送信状態を適切に処理する**: フォームが送信中であるか、成功したか、失敗したかを状態として管理し、UIに反映させます。
* **適切なローディング状態とエラー状態を表示する**: フォーム送信中にはローディングインジケータを、エラーが発生した場合には明確なエラーメッセージを表示します。
* **複雑なフォームにはフォームライブラリを使用する**: FormikやReact Hook Formなどのライブラリを使用することで、複雑なフォームのバリデーションや状態管理を簡略化できます。
* **フォームに適切なアクセシビリティを実装する**: ラベル、エラーメッセージ、タブ順序などを適切に設定し、すべてのユーザーがフォームを使いやすくします。

### エラーハンドリング (Error Handling)
* **エラーバウンダリーを実装する**: Reactコンポーネントツリー内のJavaScriptエラーを捕捉し、フォールバックUIを表示するためにエラーバウンダリー（クラスコンポーネント）を使用します。
* **非同期エラーを適切に処理する**: 非同期操作（例: API呼び出し）で発生するエラーは、`try-catch` ブロックやPromiseの `.catch()` メソッドで適切に処理します。
* **ユーザーフレンドリーなエラーメッセージを表示する**: エラーが発生した場合、ユーザーに何が起こったのか、どうすればよいのかを明確に伝えるメッセージを表示します。
* **適切なフォールバックUIを実装する**: エラーが発生した際に、アプリケーションが完全にクラッシュするのではなく、機能的な代替UIを表示します。
* **エラーを適切にログに記録する**: 開発中および本番環境で発生したエラーは、Sentryなどのツールを使用してログに記録し、デバッグと監視を容易にします。
* **エッジケースを適切に処理する**: 予期しない入力やデータ、ネットワークの状態など、あらゆるエッジケースを考慮してエラーハンドリングを設計します。

### テスト (Testing)
* **コンポーネントのユニットテストを作成する**: 各コンポーネントが単独で正しく動作するかを検証するためにユニットテストを記述します。
* **複雑なフローには統合テストを実装する**: 複数のコンポーネントやシステムが連携する複雑なユーザーフローをテストするために統合テストを記述します。
* **React Testing Libraryを使用する**: React Testing Libraryは、ユーザーの視点からコンポーネントをテストするためのツールを提供し、より堅牢なテストを促します。
* **ユーザーインタラクションをテストする**: クリック、入力、フォーム送信など、ユーザーがコンポーネントとどのようにインタラクトするかをテストします。
* **エラーシナリオをテストする**: コンポーネントがエラー状態に適切に応答するか、エラーメッセージやフォールバックUIが正しく表示されるかをテストします。
* **適切なモックデータを使用する**: API呼び出しや外部依存関係をモック（模擬）データに置き換えることで、テストの独立性と速度を向上させます。

### コード構成 (Code Organization)
* **関連するコンポーネントをグループ化する**: 特定の機能やドメインに関連するコンポーネントは、同じディレクトリやモジュール内にまとめます。
* **適切なファイル命名規則を使用する**: コンポーネントファイル名にはPascalCase、フックには `use` プレフィックスを付けるなど、一貫した命名規則を採用します。
* **適切なディレクトリ構造を実装する**: `components`, `hooks`, `utils`, `pages` など、論理的で分かりやすいディレクトリ構造を確立します。
* **スタイルをコンポーネントの近くに保つ**: スタイルは、それらが適用されるコンポーネントファイルと同じディレクトリに配置するか、CSS-in-JSライブラリを使用する場合は同じファイル内に記述します。
* **適切なインポート/エクスポートを使用する**: 相対パスではなく絶対パスを使用したり、バレルエクスポートを活用したりして、インポートパスを簡潔かつ整理された状態に保ちます。
* **複雑なコンポーネントロジックを文書化する**: 複雑なアルゴリズムや特別な考慮事項があるコンポーネントについては、コメントやREADMEファイルでそのロジックを文書化します。
