---
description: TypeScript coding standards and best practices for modern web development
globs: **/*.ts, **/*.tsx, **/*.d.ts
alwaysApply: false
---
## TypeScript ベストプラクティス

TypeScriptを効果的に活用するためのベストプラクティスを以下にまとめました。プログラミング用語は適度に英語のまま残しています。

### 型システム (Type System)
* **オブジェクト定義には `interface` を優先する**: オブジェクトの形状を定義する際には、拡張性や宣言のマージ（declaration merging）の利点から `interface` を使用することを推奨します。
* **Union、Intersection、Mapped Typesには `type` を使用する**: 共用型（Union Type）、交差型（Intersection Type）、マッピング型（Mapped Type）など、より複雑な型操作には `type` エイリアスを使用します。
* **`any` の使用を避け、不明な型には `unknown` を優先する**: `any` は型チェックを無効にするため避け、型が不明な場合はより安全な `unknown` を使用して、明示的な型アサーションや型ガードを強制します。
* **厳格なTypeScript設定を使用する**: `tsconfig.json` で `strict` モードを有効にし、可能な限り厳格な型チェックを適用します。
* **TypeScriptの組み込みユーティリティ型を活用する**: `Partial<T>`, `Readonly<T>`, `Pick<T, K>`, `Omit<T, K>` などの組み込みユーティリティ型を積極的に使用し、型の操作を簡潔にします。
* **再利用可能な型パターンにはジェネリクスを使用する**: 関数やコンポーネントで様々な型を扱う必要がある場合、ジェネリクス (`<T>`) を使用して、型安全性を保ちながら再利用性を高めます。

### 命名規則 (Naming Conventions)
* **型名とインターフェースには PascalCase を使用する**: 例: `User`, `ProductInterface`, `ButtonProps`。
* **変数名と関数名には camelCase を使用する**: 例: `userName`, `getUserData`, `calculateTotalAmount`。
* **定数には UPPER_CASE を使用する**: 例: `API_KEY`, `MAX_RETRIES`。
* **補助動詞を用いた記述的な名前を使用する (例: `isLoading`, `hasError`)**: ブール値を表す変数には、その状態を明確に示す補助動詞を付けます。
* **ReactのProps用インターフェースには 'Props' を接頭辞として付ける (例: `ButtonProps`)**: コンポーネントのプロパティを表すインターフェースであることを明確にします。

### コード構成 (Code Organization)
* **型定義は使用する場所に近づける**: 型は、それが使用されるコードの近くに定義することで、関連性と見つけやすさを高めます。
* **共有する型やインターフェースは専用の型ファイルからエクスポートする**: 複数のファイルで共有される型は、`types.ts` や `interfaces.ts` といった専用のファイルにまとめ、そこからエクスポートします。
* **エクスポートの整理にはバレルエクスポート (`index.ts`) を使用する**: ディレクトリ内のエクスポートを `index.ts` に集約することで、インポートパスを簡潔にします。
* **共有される型は `types` ディレクトリに配置する**: プロジェクト全体で共有される一般的な型は、`src/types` のような専用のディレクトリにまとめます。
* **コンポーネントのpropsはコンポーネントと共に配置する**: コンポーネントに固有のプロパティ型は、そのコンポーネントファイル自体に定義するか、そのすぐ近くに配置します。

### 関数 (Functions)
* **公開関数には明示的な戻り値の型を使用する**: 関数の戻り値の型を明示的に指定することで、コードの意図が明確になり、型安全性が向上します。
* **コールバック関数とメソッドにはアロー関数を使用する**: `this` のコンテキストが意図通りになるように、アロー関数を優先します。
* **カスタムエラー型を用いた適切なエラーハンドリングを実装する**: ドメイン固有のエラーに対してカスタムエラー型を定義し、エラーの識別と処理を容易にします。
* **複雑な型シナリオには関数のオーバーロードを使用する**: 同じ関数名で引数の型や数によって異なるシグネチャを持つ場合、オーバーロードを使用して型定義の正確性を高めます。
* **Promisesよりもasync/awaitを優先する**: 非同期処理には `async/await` を使用することで、コードの可読性と保守性が向上します。

### ベストプラクティス (Best Practices)
* **`tsconfig.json` で厳格モードを有効にする**: `noImplicitAny`, `strictNullChecks` などの厳格なオプションを有効にし、TypeScriptの恩恵を最大限に活用します。
* **不変なプロパティには `readonly` を使用する**: オブジェクトのプロパティが一度設定されたら変更されない場合、`readonly` 修飾子を付けて不変性を強制します。
* **型安全性のために判別可能なUnionを使用する**: Union型と判別プロパティ（discriminant property）を組み合わせることで、特定の型のメンバーにアクセスする際の型安全性を確保します。
* **実行時型チェックには型ガードを使用する**: `typeof` や `instanceof`、カスタムの型ガード関数を使用して、実行時に変数の型を絞り込みます。
* **適切なNullチェックを実装する**: `strictNullChecks` を有効にし、Optional Chaining (`?.`) や Nullish Coalescing (`??`) などの機能を使って、NullやUndefinedの可能性を適切に処理します。
* **必要でない限り型アサーションを避ける**: 型アサーション (`as Type`) は型チェッカーを上書きするため、本当に型が正しいことを保証できる場合にのみ使用し、代わりに型ガードを優先します。

### エラーハンドリング (Error Handling)
* **ドメイン固有のエラーにはカスタムエラー型を作成する**: アプリケーションのビジネスロジックに特化したエラーを定義し、より意味のあるエラー処理を可能にします。
* **失敗する可能性のある操作には Result 型を使用する**: 成功と失敗のいずれかの結果を明示的に返す Result 型（例: `Result<T, E>`）パターンを検討し、エラーハンドリングのフローを明確にします。
* **適切なエラーバウンダリーを実装する**: Reactなどのフレームワークでは、UIコンポーネントのエラーをキャッチしてフォールバックUIを表示するエラーバウンダリーを使用します。
* **型付きの `catch` 句を持つ `try-catch` ブロックを使用する**: TypeScript 4.4以降では `catch` 句の変数を `unknown` として型付けし、その型を適切に絞り込んでエラーを処理します。
* **PromiseのRejectionを適切に処理する**: `Promise.catch()` を使用して、非同期操作で発生したエラーを確実に捕捉し、処理します。

### パターン (Patterns)
* **複雑なオブジェクト作成にはビルダーパターンを使用する**: オブジェクトの構築プロセスが複雑な場合、段階的にオブジェクトを構築できるビルダーパターンを適用します。
* **データアクセスにはリポジトリパターンを実装する**: データソース（データベース、APIなど）へのアクセスを抽象化するためにリポジトリパターンを使用し、ビジネスロジックとデータアクセス層を分離します。
* **オブジェクト作成にはファクトリーパターンを使用する**: オブジェクトのインスタンス化ロジックをカプセル化し、オブジェクト作成の柔軟性を高めます。
* **依存性注入を活用する**: クラスが依存するオブジェクトを外部から注入する依存性注入（Dependency Injection）を使用し、テスト容易性とモジュール性を向上させます。
* **カプセル化にはモジュールパターンを使用する**: 関連するコードとデータをグループ化し、外部からアクセスできるインターフェースを制限することで、コードの組織化と保守性を高めます。
